import cv2
import json
from matplotlib import pyplot as plt
import numpy as np 
import os
import argparse
from imgaug import augmenters as iaa
import glob
from PIL import Image


parser = argparse.ArgumentParser(description="Retrieval Image Augmentation with local features")
parser.add_argument("--img-top-path", dest="img_top", type=str, help="images waited to be processed as foreground path")
parser.add_argument("--img-bottom-path", dest="img_bottom", type=str, help="images waited to be processed as foreground path")
parser.add_argument("--mask-path", dest="mask", type=str, help="where to save mask")
parser.add_argument("--json-path", dest="json", type=str, help="load json generated by via-1.0.6")
parser.add_argument("--save-path",dest="save_path", type=str, help="where to save augmented images")

args = parser.parse_args()  
# if not os.path.exists(args.mask):
#     os.mkdir(args.mask)

top_path = args.img_top
bottom_path = args.img_bottom


def get_ROI(img, b):
    """
    :type img: image name
    :rtype mask
    """
    im = np.zeros(img.shape[:2], dtype = "uint8")
    cv2.polylines(im, b, 1, 255)  
    cv2.fillPoly(im, b, 255)  

    mask = im
    masked = cv2.bitwise_and(img, img, mask=mask) 
    return masked

def mask_aug(top_mask, bottom_img, img_index):
    """
    :type top_mask: 
    :type bottom_img: bottom image name
    :rtype overlapping image
    """
    seq_1 = iaa.Sequential([iaa.Fliplr(0.5)])
    seq_2 = iaa.Sequential([iaa.Flipud(0.5)])
    seq_3 = iaa.Sequential([iaa.Affine(translate_percent={"x": (0.2), "y": (0.2)})])
    seq_4 = iaa.Sequential([iaa.Affine(scale={"x": (0.8), "y": (0.8)})])
    seq_5 = iaa.Sequential([iaa.Affine(rotate=(0.5))])
    seq_6 = iaa.Sequential([iaa.Affine(rotate=(-45))])
    seq_7 = iaa.Sequential([iaa.Affine(rotate=(30))])
    seq_8 = iaa.Sequential([iaa.Affine(rotate=(90))])
    seq_all = [seq_1, seq_2, seq_3, seq_4, seq_5, seq_6, seq_7, seq_8]

    for j in range(len(seq_all)):
        bottom = cv2.imread(bottom_img)
        b_h, b_w = bottom.shape[:2]
        top = seq_all[j].augment_image(top_mask)
        t_h, t_w = top.shape[:2]
        # top = cv2.resize(top, [b_w, b_h, 3])
        flag = (top[:,:] != (0,0,0))
        bottom[flag] = top[flag]
        cv2.imwrite(os.path.join(args.save_path, bottom_img.split(".")[0]+"{}.png".format(img_index*j)), bottom)

if __name__ == "__main__":
    # clean image name
    with open(args.json, "r") as f:
        data = json.load(f)

    fake_key = data.keys()
    for k in fake_key:
        real_key = k.split(".")[0] + ".png"
        data[real_key] = data.pop(k)

    for pic in glob.glob(top_path+"/*"):
        if pic.endswith(".png"):
            img_name = pic.split("/")[-1]
            regions = data[img_name]["regions"]
            obj_num = len(regions)
            coor = dict.fromkeys([str(m) for m in range(obj_num)])
            mask = dict.fromkeys([str(m) for m in range(obj_num)])
            for i in range(obj_num):
                points_num = len(regions["{}".format(i)]["shape_attributes"]["all_points_x"])
                co = []
                for j in range(points_num):
                    x = regions["{}".format(i)]["shape_attributes"]["all_points_x"][j]
                    y = regions["{}".format(i)]["shape_attributes"]["all_points_y"][j]
                    co.append([x,y])
                coor["{}".format(i)] = co
                img = cv2.imread(pic)
                mask["{}".format(i)] = get_ROI(img, np.array([coor["{}".format(i)]], dtype=np.int32))
            for bo in glob.glob(bottom_path+"/*"):
                for k, v in mask.items():
                    mask_aug(v, bo, k)





        

